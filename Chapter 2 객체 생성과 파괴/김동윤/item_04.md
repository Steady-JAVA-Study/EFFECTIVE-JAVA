
# 인스턴스화를 막으려거든 private 생성자를 사용하라

- 정적 메소드와 정적 필드만을 담은 클래스 만들고 싶은 경우 존재
(ex)
> - java.lang.Math , java.util.Arrays 같이 기본타입값, 배열 메소드 모아놓은 것, - java.util.Collection 처럼 특정 인터페이스 구현하는 객체 생성해주는 정적 메소드 모아두기 가능
- final 클래스와 관련한 메소드 모아놓을 때도 사용- final클래스 상속해서 하위 클래스에 메소드 담는 것은 불가능하기 때문



- 동일한 입력값을 넣으면 항상 동일한 결과를 리턴하는 메서드를 만든다고 했을 때, 메서드는 어디서든 사용될 수 있으며 있는 그대로 재사용이 가능
- 이런 상황에서는 인스턴스를 생성하지 않고 전역에서 사용할 수 있으며 항상 재사용이 가능하도록 하는 것이 더 효율적입니다 => 이를 정적(static) 선언으로 구현 가능

- 항상 전역으로 사용할 수 있는 정적 필드와 정적 메서드가 모인 클래스 : 유틸성 클래스
- 보통 유틸성 클래스는 필드와 메서드 모두 정적(static) 선언으로 구현

## 생성자의 접근제한자를 private 으로 주면 다른 클래스에서 생성자를 호출 X ➡ 생성 X

public class StringUtil {

	// 기본 생성자가 생성되는 것을 막는다. (인스턴스화 방지용)
	private StringUtil(){
		throw new AssertionError();
	}

	...

- 단순히 추상클래스로만 선언한다고 인스턴스화 막을 순 없음
- 추상클래스의 구현체 만들어서 인스턴스화 가능 & 누군가는 이를 상속하라는 것으로도 이해 가능
- 인스턴스화 막기 위해서는 private 생성자 추가하면 됨 
=> 컴파일러가 기본 생성자 만드는 경우 (public 생성자 ) 는 아무 생성자도 없는 경우 => private 생성자 추가하기 

- 이는 상속을 막는 효과도 존재 
