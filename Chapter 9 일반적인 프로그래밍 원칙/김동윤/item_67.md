# 최적화는 신중히 하라
> 맹목적인 어리석음(blind stupidity)을 비롯한 다른 어떤 이유보다도, 효율성이라는 이름으로 저질러지는 죄악이 더 많다(효율성을 반드시 성취하는 것도 아니면서 말이다). - 윌리엄 울프(William A. Wulf)
  
>  작은 효율성(small effiency)에 대해서는, 말하자면 97% 정도에 대해서는, 잊어버려라. 섣부른 최적화는 모든 악의 근원이다. - 도널드 커누스(Donald E. Knuth)
  
>  최적화를 할 때는 아래의 두 규칙을 따르라.  규칙1: 하지마라  규칙2: (전문가들만 따를 것) 아직은 하지마라 - 완벽히 명료한, 최적화되지 않은 해답을 얻을 때까지는. - M. A. 잭슨(M. A. Jackson)


___________________
# 설계 단계의 주의사항
## 1. 성능을 제한하는 설계는 피하자.
완성 후 변경하기 가장 어려운 설계 오소가 컴포넌트 간 혹은 외부 시스템과의 소통 방식이다. API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등을 대표적인 예로 들 수 있다. 이러한 부분은 완성 후 변경하기 어렵거나 불가능할 수 있기 때문에 시스템 성능을 제한하지 않는 설계가 필요하다.

 

## 2. API를 설계할 때 성능에 주는 영향을 고려하자.

### 2-1. public 타입을 가변으로 만들어 내부 데이터를 변경할 수 있다면, 불필요한 방어적 복사를 유발할 수 있다.

> - **방어적 복사 **
   - 생성자를 통해 초기화 할 때, 새로운 객체로 감싸서 복사해주는 방법이
   - 외부와 내부에서 주소값을 공유하는 인스턴스의 관계를 끊어주기 위함


- (EX) java.awt.Component클래스의 getSize 메서드
   - API 설계자는 getSize()가 호출되면 새로운 Dimension인스턴스를 반환하게 설정
   -  Dimension은 가변으로 설계했으니 getSize를 호출하는 모든 곳에서 인스턴스를 (방어적으로 복사하느라) 새로 생성



- 잘 설계된 API는 성능도 좋은 게 보통이다. 그러니 성능을 위해 API를 왜곡하는 건 매우 안 좋은 생각이다. 
   - 성능 문제는 다음 버전에서 사라질 수는 있겠지만 왜곡된 API와 이를 지원하는데 고통은 지속되기 때문 ㅇㅇ 

### 2-2. 컴포지션으로 해결할 수 있음에도 상속으로 설계한 public 클래스
- 컴포지션 
   - 기존의 클래스가 새로운 클래스의 구성요소에 사용되는 것
   -  기존 클래스를 확장(상속)하는 대신, 새로운 클래스를 만들고 private필드로 기존 클래스의 인스턴스를 참조하게 한다.
   - 이렇게 되면 새로운 클래스는 기존 클래스의 영향이 적어지고 기존 클래스 안에 새로운 메소드가 추가되도 안전하다. 상속의 경우 부모 클래스를 수정하면 자식 클래스도 같이 수정해야하는 경우가 발생하기 쉽다.
```java
public class B extend A{  //상속

	...
    
}

public class B{  //컴포지션

    private A a;

}
```



## 3. 성능을 위해 API를 왜곡하지 말자.
- 성능 문제를 위해 왜곡된 API를 만들게 되면, 지금 당장의 성능 이슈는 해결될지 몰라도 그 API를 지원하는데 따르는 고통은 영원히 계속될 것이다. 그러니 API를 왜곡 X

## 결론

- 최적화 보단 초기 API설계에 집중하라. 
   - 좋은 프로그램을 작성하면 성능은 따라오기 마련이다.
- 단, 시스템을 설계할 때, 특히 API, 네트워크 프로토콜, 영구 저장용 데이터 포멧을 설계할 때는 성능을 염두에 두기
- 시스템 구현을 완료했으면 성능을 측정해봐라. 
- 적당히 빠르면 그걸로 끝이다. OR NOT, 프로파일링 도구로 문제의 원인이 되는 지점을 찾고 가장먼저 어떤 알고리즘을 사용했는지 확인 
- 알고리즘을 잘못 골랐다면 다른 저수준 최적화는 아무리해도 큰 소용이 없다. 

 
## REFERENCE 
https://jgrammer.tistory.com/
https://jjingho.tistory.com/116