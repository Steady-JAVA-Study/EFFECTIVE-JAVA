# GENERIC ?
- 제네릭 지원 전에는 컬렉션에서 객체 꺼낼 때마다 , 이 객체의 타입이 뭔질 모르니 형변환 과정이 필수
- 그러나 누가 엉뚱 객체 넣어둔다면 형변환 시 에러가 나게되지 , 언제? 런타임에
- 따라서 제네릭 사용하면 컬렉션이 담기 가능한 타입을 컴파일러 차원에서 잡기가 가능이지
- 엉뚱 타입 객체 넣으려는 시도를 컴파일 과정서 차단 가능
- 클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다.

제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입

# Raw 타입은 사용하지 말라
## RAW TYPE : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않는 것
> - 컴파일 시점에 에러를 잡을 수가 없음


- 타입(타입 매개변수가 없는 제네릭 타입)을 쓰는 걸 언어 차원에서 막아 놓지는 않았지만 절대로 써서는 안 된다

## 비한정적 와일드 카드 타입(unbounded wildcard type) !
- 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않다면 로 타입을 사용하지말고 비한정적 와일드카드 타입을 사용하라. (물음표로 타입을 작성)
- 어떤 타입이라도 담을 수 있는 범용적인 매개변수화 타입이다.
- 타입 불변식을 훼손하지 못하도록 막았기 때문에 다른 원소를 넣으려하면 컴파일시에 오류로 알려준다.

 
## RAW TYPE 사용 경우도 존재
로 타입도 사용해야할 때가 있다.

1. class 리터럴
- List.class, String[].class, int.class는 허용
- List<String>.class, List<?>.class는 허용하지 않는다.
2. instanceof 연산자
비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.

```
if(o instanceof Set) {  //raw type
   Set<?> s = (Set<?>)o;  //wildcard type
}
```

- o의 타입이 Set 임을 확인한 후에 와일드카드 타입인 Set<?>로 형변환해야한다.

 
  
## 출처 
https://happy-playboy.tistory.com/entry/Item-26-%EB%A1%9C-%ED%83%80%EC%9E%85%EC%9D%80-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC

## 핵심
- Set<Object>와 Set<?>는(비한정적 와일드카드 타입) 안전하지만, Set은 안전하지 않다.
  - https://codingwell.tistory.com/108