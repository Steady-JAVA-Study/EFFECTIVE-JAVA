# 아이템 82. 스레드 안전성 수준을 문서화하라

* API 문서에 스레드 안정성에 대한 내용이 없으면 사용자는 동기화를 부족하게 하거나 과하게 하는 경우가 생길 수 있다.
* 멀티스레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안전성 수준을 명시해야 한다.
* 다음은 스레드 안정성 수준이 높은 순으로 나열한 것이다.

### 불변
* 이 클래스의 인스턴스는 마치 상수와 같아서 외부 동기화도 필요 없다.
* ex. `String`, `Long`, `BigInteger`

### 무조건적 스레드 안전
* 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 동시에 사용해도 안전하다.
* ex. `AtomicLong`, `ConcurrentHashMap`
> Atomic 변수는 원자성을 보장하는 변수로, 여기서 원자성은 멀티스레드 환경에서 특정 시점에 어떤 메서드를 여러 스레드가 동시에 호출하지 못하는 것을 의미한다.

### 조건부 스레드 안전
* 무조건적 스레드 안전과 같으나, 일부 메서드는 동시에 사용하려면 외부 동기화가 필요하다.
* ex. `Collections.synchronized` 래퍼 메서드가 반환한 컬렉션들

### 스레드 안전하지 않음
* 이 클래스의 인스턴스는 수정될 수 있다.
* 동시에 사용하려면 각각의 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야 한다.
* ex. `ArrayList`, `HashMap` 같은 기본 컬렉션

### 스레드 적대적
* 이 클래스는 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다.
* 이 수준의 클래스는 일반적으로 정적인 데이터를 아무 동기화 없이 수정한다.

## Lock 제공
* 외부에서 사용할 수 있는 락을 제공하면 클라이언트에서 메서드 호출을 원자적으로 수행할 수 있다.
* 내부에서 처리하는 고성능 동시성 제어 메커니즘과 혼용이 안 된다.(ex. `ConcurrentHashMap` 과 사용 X)
* 클라이언트가 공개된 락을 오래 쥐고 놓지 않는 서비스 거부 공격을 수행할 수도 있다.
* `synchronized` 메서드도 공개된 락에 속한다.
* 비공개 락 객체를 사용해야 한다.

```java
// 비공개 락 객체, final 선언 : 락 객체 교체 상황 방지를 위함
private final Object lock = new Object();

public void someMethod() {
  synchronized(lock) {
    // do something
  }
}
```