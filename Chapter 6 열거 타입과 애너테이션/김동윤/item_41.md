# 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

## 마커 인터페이스
- 아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시 해주는 인터페이스
- 자신을 구현하는 클래스가 특정 속성을 가짐을 나타내는 인터페이스
- 추상 메서드든, 필드든, default, static 메서드든 아무것도 없다.
- Cloneable, Serializable 같은 인터페이스

![](https://velog.velcdn.com/images/myway00/post/b57e3683-57d9-43d9-89c2-be9e18f2e417/image.png)

## 마커 어노테이션
- 해당 요소가 특정 속성을 가짐을 나타내는 에너테이션
- @Override, @FunctionalInterface, @SafeVarargs, @Native

## 마커 어노테이션(RUNTIME) VS 인터페이스 (COMPILE)
- 마커 인터페이스와 마커 에너테이션 모두 클래스가 어떤 속성을 가진다는 표시  가능
- 마커 인터페이스는 타입으로 사용하여 컴파일타임 에 오류를 검출 가능
- 마커 에너테이션은 런타임에서야 오류를 검출

## 마커 인터페이스의 장점
- 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 사용가능  (마커 애너테이션은 그렇지 않다.)
- 마커 인터페이스는 컴파일타임에 오류를 발견할 수 있다. (마커 애너테이션은 런타임 )
-적용 대상을 더 정밀하게 지정 가능
그러면 마킹된 타입은 자동으로 그 인터페이스의 하위타입이 보장된다.
- 마커 인터페이스는 객체의 특정 부분을 불변식으로 규정하거나,
그 타입의 인스턴스는 다른 클래스의 특정 메서드가 처리 할 수 있다는 사실을 명시하는 용도로 사용 할 수 있다.
(Serializeable 인터페이스가 ObjectOutputStream이 처리할 수 있는 인스턴스이듯이)

## 결론
- 마커 인터페이스와 마커 애너테이션은 각자의 쓰임이 있다.
- 새로 추가하는 메서드 없이 단지 **타입 정의**가 목적이라면 마커 인터페이스를 선택하자
- 마커 애너테이션을 사용할 때 @Target(ElementType.TYPE)인 마커 애너테이션을 작성하고 있다면,
마커 애너테이션을 정말 사용해야 하는지? 마커 인터페이스를 사용할 수 있는지 생각해보고
웬만하면 마커 인터페이스를 사용 ~
   - @Target : 해당 사용자가 만든 어노테이션이 부착될 수 있는 타입을 지정하는 것


## REFERENCE
 https://seeminglyjs.tistory.com/249  
 https://jaehun2841.github.io/2019/02/04/effective-java-item41/